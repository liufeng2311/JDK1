##基础面试题

###hashcode()和equals()
 * 1.默认hashcode()和equals()返回的是什么？
        
        hashcode()和equals()都定义在Object中。
        hashcode()默认是native方法,通过将对象的内存地址和对象具体信息转化为一个数值信息。
        equals()默认实现为 ==, 比较的是内存地址。
 * 2.既然有了equals()方法，为什么还要有hashcode()方法？
        
        当我们比较一个集合是否存在某一个元素时,我们可以遍历集合中的元素和已知元素通过equals比较,当集合中的元素
        比较多时,效率就会变低,于是提出了hashcode()
        
        hashcode()和equals()方法存在如下关系：
        
        对象的hashcode不同时,对象必定不相等
        对象的hashcode相同时,对象不一定相等
        对象相等时,对象的hashcode必定相同
        
        如果还是通过遍历的方式先比较hashcode()再比较equals()的话反而会降低比较的效率,
        如果我们通过K,V的形式将hashcode作为K,V用来存储hashcode对应的对象,既可以通过hashcode减少需要比较的数量
        hashcode()返回值是一个整数,整数的范围比较大,我们可以进一步的通过与一个固定值进行&运算来缩小范围
        
        
 * 3.什么时候需要重写、如何重写？
       
       我们自定义的对象不需要重写hashcode()和equals()方法,只有当该类用作K,V中的K值,才需要重写,常见的就是HashMap
       
       基本类型的包装类和String的hashcode()和equals()已经被重写,我们自定义类如果只有基本数据类型的话,只需要调用所有基本类型
       属性值的hashcode()和equals()方法即可
       
       IDEA为我们提供了默认的实现
       
    
###ArrayList和LinkedList的区别

 * ArrayList        
       ArrayList底层数据的存储是数组,数组是一个连续的空间,数组创建时长度是确定的,可以通过索引快速定位和获取数组中的元素
       当我们在数组中间添加或者删除元素时,为了保证数据的连续性,需要移动元素的位置来保证
       当数据超过数组长度时,ArrayList底层是通过创建新的数组后转移数组元素实现的

 * LinkedList      
       LinkedList底层数据的存储是链表,链表不需要连续的空间,同时链表的长度是不确定的
       不连续的空间注定链表的查找只能通过遍历来实现
       链表的删除和新增要比数组快的多,不需要移动元素,只需要改变两个元素的指针即可实现
           
### synchronized

 * 1.synchronized的原理
        
       synchronized锁的是对象的实例,锁的信息位于对象中,具体分为类实例和对象实例。
       类实例(类锁)：
            
            类实例是一种特殊的实例对象,我们反射用到的对象。加锁方式有如下两种
       类锁1：
            synchronized(Calass.class){}
       类锁2:
            static synchronized void test(){}
       实例锁(对象):
            锁住的是具体的实例对象。
       实例锁1：
            synchronized(this){}
            synchronized(obj){}
       实例锁2：
            synchronized void test(){}
       
 * 2.synchronized注意点
        
        synchronized修饰的方法被子类重写时,子类不会继承该关键字
        
### JAVA中的锁实现有哪些

 * Java中的锁有哪些分类(概念层次划分)
        
        乐观锁和悲观锁
        公平锁和非公平锁
        可重入锁和非可重入锁
        独享所和共享锁
        自旋锁和自适应自旋锁
        
 * Java中的锁有哪些实现
        
        synchronized
        AQS
        CAS
 
 * Java中有哪些具体的锁
        
        AQS的实现：
            ReentrantLock：读锁(独占锁)
            ReentrantReadWriteLock：读写锁(共享锁和独占锁)
            CountDownLatch：一个线程等待其他线程都执行完成了才能继续执行
            CyclicBarrier：达到指定数量的线程后,这些线程再统一执行
            Semaphore：设置最多同时执行的线程数
            
        CAS的实现：
            
            AtomicInteger
            
### 自己设计一个线程池
        
 * 设计思路
        
        任务体(创建名称,创建ID,记录任务开始执行时间、任务结束时间)
        存储任务的载体队列(保存提交上来的任务体)
        执行任务的线程(线程何时创建,何时回收,如何获取任务体,最多创建多少线程,最少创建多少线程,异常时如何处理)
        队列满时任务的丢弃策略(丢弃时记录任务,后期如何处理)
        
        
### 数据库事务

 * 事务的四大特性(ACID)
        原子性：要么全部成功、要么全部失败。
        一致性：事务从一个一致状态转变为另一个一直状态。
        隔离性：一个事务内的操作不收其他事务影响。
        持久性：事务的修改会被永久保存。
        
 * 事务间存在的问题
        
        脏读：读取到别的事务未提交的数据。
        幻读：
        不可重复读：两次相同的查询读取到的数据不同
 
 * 事务的隔离级别
        
        读未提交
        读已提交
        可重复读
        串行读
 
 * MYSQL默认隔离级别,如何实现可重复读的
 
 * 回滚是如何实现的

### 数据库中有哪些锁(InnoDB)

 * MYSQL有哪些锁,如何加锁
        
        表锁：没有使用索引查询时会自动获得表锁
        行锁-共享锁: lock in share mode
        行锁-排它锁: for update
 * 锁是如何实现的
        
        行锁：行锁位于索引上,如果不经过索引加锁的话,使用的是表锁而不是行锁
        
### MYSQL如何优化


### redis如何持久化的,主从间如何实现同步,如何处理过期的数据
       
        
        
        