## MySQL

### 数据库设计的三大范式

* 第一范式

       表中的每一项数据都是不可分割的(每个字段都只能存储一个独立的信息)
* 第二范式

       表中所有的非主键列都只能和主键存在唯一确定关系(主键包括唯一主键或联合主键)
       当为联合主键时,非主键列必须和整个联合主键存在唯一确定关系, 而不是联合主键中的某些列
* 第三范式

       非主键列各个字段相互独立,之间不存在传递依赖(防止数据冗余,比如存了用户ID就不能存用户姓名)
* 遵守规则

       第一范式和第二范式必须遵守,
       第三范式在某些场景下可以不遵守(适当的冗余可以减少表关联查找,比如同时存储字典表中的code和name),
       不遵守第三范式也会存在一定的问题, 比如字典表中的某code对应的name发生修改时,我们需要全量修改未遵守第三范式的表数据。

### SQL

* SQL的定义

      SQL是一种结构化查询语言(Structured Query Language), 专门用来与数据库打交道，目的是提供一种从数据库中读写数据的简单有效的方法。
      几乎所有的主流关系数据库都支持SQL,适用性非常强。一些非关系型数据库也兼容SQL或者使用的是类似于SQL的查询语言。

### 事务的四大特性(ACID)

* 原子性

       事务中的操作要么全部成功,要么全部失败。

* 一致性(不同会话中)

       解释一:
       它保证了事务执行前、执行中、执行完毕，数据库都必须保持一致状态。符合我们正常的思维预知, 
       比如转账前后两个账户的总额不变, 转账期间两个账户显示的金额总额不变。

       解释二:
       事务执行前、执行中、执行完毕，其他会话同一时间观察到的数据总是一致的。
       比如A会话在执行事务时, B会话看到的是100, 那么C会话此时观察到的也一定是100。

* 隔离性(不同会话中)

       不同事务中数据的可见性
       并不意味着各个事务见完全不可见(四种隔离级别)

* 持久性

       事务一旦提交就会被永久保存。数据会被永久保存到硬盘。

### 并发事务带来哪些问题

* 脏读

       一个事务可以读取其他事务中未提交的数据。
       该数据可能因为其他事务回滚而变成无效数据。

* 不可重复读(针对的是所有的查询语句)

       一个事务中相同的查询语句在多次执行中返回不同的结果。
       查询单条数据记录时返回的不一致
       查询结果集时返回的结果集不一致。

* 幻读

       在可重复读的模式下, 事务察觉不到其他事务对数据的改变。对于那些被其他事务改变的数据,导致该事务感觉自己读到的数据不对。
       
       事务A操作如下：
       1、打开事务
       2、查询号码为X的记录，不存在
       3、插入号码为X的数据，插入报错(提示该号码已存在)
       4、查询号码为X的记录，发现还是不存在(由于是可重复读, 事务读取不到最新的数据, 所以在看看来X还是不存在的)
       
       事物B操作：在事务A第2步操作时插入了一条X的记录，所以会导致A中第3步插入报错（违反了唯一约束）
       
       上面操作对A来说就像发生了幻觉一样，明明查询X（A中第二步、第四步）不存在，但却无法插入成功

### 隔离级别

* 读未提交(Read uncommitted)

       可以读取到其他事务还未提交的数据, 多次读取结果不一样。
       出现了脏读、不可重复读

* 读已提交(Read committed)

       只能读取到其他事务已经提交的数据, 多次读取结果不一样
       出现了不可重复读

* 可重复读(Repeatable read)

       只能读取到当前事务开始前已经提交的数据, 多次读取结果一样
       出现了幻读

* 串行读(serializable)

       事务顺序执行, 不会出现问题

### MYSQL和ORACLE默认的隔离级别分别是什么

* MYSQL

       采用的隔离级别是可重复读
* ORACLE

       采用的隔离级别是读已提交

###十、MVCC机制、间隙锁
* 读锁和写锁

       学习MVCC机制前我们必须理解MYSQL中的读锁和写锁,MYSQL中的读写锁其实和JAVA中的读写锁类似,MYSQL中的行锁是在聚簇索引中实现的(意味着不走索引只能获取表锁)
       当访问行的数据的读锁被其他事务获取时,此时只能获取他的读锁
       当访问行的数据的写锁被其他事务获取时,此时只能等待,既不能读也不能写
       
       MVCC中的多版本访问指的是访问某一行数据的某个版本, 访问最新版本数据时必须获取该行数据的读锁

* undo log文件

       该文件有两个作用: 回滚 + MVCC
       我们需要明确的是多版本访问和本事务回滚是没有任何联系的
       回滚指的是回滚本事务的所有修改操作,本事务必然持有被修改行的写锁,其实其他事务是无法读取到这些行的数据的
       MVCC指的是我访问某行数据之后,该行数据被其他事务修改并提交了,我再次访问时只能访问其他事务未修改前的版本,其他事务获取写锁未提交期间是访问不到该行数据的
* MVCC

       MVCC的多版本是针对行而言的,同一时刻undo log可能同时存在一个数据的多个版本
       根据当前行中的数据以及undo log中的语句就可以得到该行各个版本的数据

* 事务回滚的原理

       事务中的每次修改操作都会在undo log中生成相反的sql语句, undo log中生成的语句总能使数据恢复原样
       我们新增语句会生成一条删除语句    
       我们删除语句会生成一条新增语句    
       我们更新语句会生成一条更新语句    

* MVCC是如何实现快照读的

        一个事务访问某行数据时发现该行数据可能存在多个版本链,如何选择读取哪个版本呢
        事务的ID是按照时间增序的, 每个事务在生成时都会保存当前处于活跃状态的事务ID列表,每条数据修改时都会保存修改它的事务ID, 判断规则如下
        
        1. 数据的事务ID正好是当前事务,说明当前事务含有数据的写锁,该版本可以访问
        2. 数据的事务ID小于活跃事务集合中的最小ID,说明该数据没有被修改过,该版本可以访问
        3. 数据的事务ID大于活跃事务集合中的最大ID,说明该数据被修改过,该版本不可以访问
        4. 数据的事务ID属于活跃事务集合时,说明数据被修改过,该版本不可以访问
        
        概括：
        该事务只能访问小于等于自己版本的数据,如果发现最新版本的事务ID大于自己,通过链表向下查找到小于自己的版本

* 版本链的回收机制

        处于活跃状态的最小事务ID大于该版本时,该版本才会被回收

* 幻读

        MYSQL中的幻读指的是一个事务可以读取到其他事务新增的数据

* RR和RC下的幻读

        RR模式下的读是快照读, 读取的是版本数据, 是不存在幻读的, 只有当读操作加锁时才会出现幻读
        RC模式下的读是最新读, 读取的是最新数据, 存在幻读

* RR下的幻读是如何解决的(间隙锁)

       出现幻读的原因有两个：
       1. 其他事物新增
       2. 本事务的查询是范围查找
       
       我们通过加锁的方式将范围内的所有数据加锁(包括不存在的数据), 这样就保证了其他事务无锁新增而保证本事务不会出现幻读
       对于那些不存在的数据的锁就是间隙锁

* 间隙锁的应用场景

       生产环境数据出错,需要范围批量修改, 此时必须使用间隙锁, 防止修改期间对新增数据也造成修改      

### MYISAM和INNODB

* MYISAM

      1. 不存在事务
      2. 不支持外键
      3. 采用非聚簇索引,索引保存的是数据的地址
      4. 通过一个字段保存了表的具体行数, 查询行数快
      5. 只支持表锁

* INNODB

       1. 支持事务。每一条修改sql语句都默认为封装为一个事务,自动提交。
       2. 支持外键
       3. 采用聚簇索引
       4. 不保存行数, 因为事务的原因, 不同的事务中行数时不一致的,需要事务自己去统计
       5. 支持表锁和行锁, 行数是在索引上实现的。意味着没有命中索引的语句会使用表锁。

### B-Tree、B B+Tree和Hash的区别

* B-Tree
    
      B-Tree是一种多路平衡查找树, 通过增加叶子节点的数量和减少树的层数, 数据存储在每个节点中, 数据层数越小,查找效率更高。

* B+Tree

      B+Tree在B-Tree的基础上进行了优化, 主要包括如下几点：
      1. B-Tree的查找效率不稳定, B+Tree将所有的数据都保存在了最底层, 非叶子节点仅保存主键标识, 因此查找效率稳定。
      2. B-Tree不支持范围查找, B+Tree将相邻的节点通过双向连表实现, 实现了范围查找。

* Hash

      Hash等值查找效率更高,但不支持排序和范围查找

### 索引类型

* 聚簇索引

       索引和具体的数据保存在一个节点中,找到索引就找到了数据
* 非聚簇索引

       索引和具体的数据保存在不同的节点中,非聚簇索引保留的是聚簇索引的索引值
* 联合索引(组合索引)

       多个字段共同作为索引,遵循最左匹配原则
* 覆盖索引

       查询的数据正好位于索引中,不需要再次回表
* 唯一索引

       数据不可以出现重复,可以为空
* 主键索引

       数据唯一且不能为空

### 索引的优缺点

* 优点

       提升数据查询速度, 较少数据查询耗时。
* 缺点

       1. 更新数据时,我们需要同步的更新索引,更新耗时增加
       2. 索引需要额外的存储空间

### MYSQL为什么使用B+Tree作为索引

* 原因

       主要和磁盘的IO次数有关, B+Tree由于非叶子节点仅保存索引数据,因此可以使用更少的IO获取想要的数据
       MYSQL采用页的数据结构和磁盘每次能读取的保存一致,查询出数据的时候还能预加载数据

### SQL优化

* 表字段设置合理的冗余可以避免表关联
* 禁止使用三表及三表以上关联
* 禁止全字段查询, 避免查询无用字段
* 创建合理索引并防止索引失效

       避免select *造成覆盖索引失效,无用的字段会影响查询效率和占用内存
       字段最好设置默认值,避免NULL值的出现,因为NULL值可能造成影响索引失效
       过滤条件不要使用模糊查询, 即使使用左侧也必须是确定的
       避免使用not in和 !=
       索引字段的数据类型必须一致,否则索引会失效
       当in和or中的字段为索引时,使用union all,mysql会自动帮我们优化
       过滤语句左侧不可以出现表达式,右侧可以
       当一个字段的取值范围固定且存在大量重复,使用索引的意义不大
       索引的个数控制在最多六个,不然造成更新效率低且占据空间
       尽量使用数值类型,而不是字符串

### MYSQL中存在哪些锁(锁都是针对不同的事务,类似多线程)

* 概括

       MYSIAM只存在表锁,不会发生死锁问题
       InnoDB存在表锁和行锁(细分为读锁和写锁),行锁就意味着会出现死锁
       行锁是通过索引实现的,不经过索引的话就意味着获取的是表锁
       在事务未执行完成前是不会释放锁的
* 读锁

       select * from person_info where id = 1 lock in share mode;
* 写锁

       select * from person_info where id = 1 for update;
* 行锁

       对某一行数据加锁, 该锁位于主键索引处, 行锁分为读锁和写锁
* 表锁

       对整张表加锁

* 悲观锁

       悲观锁指的就是行锁

* 乐观锁

       通过一个version字段进行控制

* 间隙锁(针对范围查找)

       为了解决查询当前版本的幻读问题,InnoDB会对范围内的所有不存在数据加锁
       例子：
       ID类型为自增,当前最大ID为10, 当前事务查询ID>9的数据(获取大于9的所有不存在数据加间隙锁), 此时其他事务新增都会阻塞

### 死锁如何查看和解决

* 死锁发生的条件

       MYSIAM中只有表锁,是不会发生死锁的
       INNODB中存在行锁,只有行锁才会发生死锁

* MYSQL死锁的解决

       MYSQL内部存在死锁处理机制, 死锁50秒就会触发机制,我们可以设置触发时间并记录日志
       查看死锁处理机制触发时间 ：show variables like '%innodb_lock_wait_timeout%';        
       设置死锁日志到mysql错误日志：show variables like '%innodb_print_all_deadlocks%';

* 开发中避免死锁

       程序中不同方法访问资源的顺序是一致的
       一个事务中不要存在太多的操作

### 十五、慢查询如何查询
      
### 十六、事务的操作与设置

* 事务类型

       隐式事务：事务自动开启、提交或回滚，比如insert、update、delete语句，事务的开启、提交或回滚由mysql内部自动控制的。
       显式事务：手动开始事务、提交事务、回滚事务

* 查看事务类型

       show variables like 'autocommit';

  |Variable_name|Value|Desc|
           |:---:|:---:|:---:|
  |autocommit|ON|开启自动提交|
  |autocommit|OFF|未开启自动提交|

* 设置提交类型

       set autocommit=0;  //关闭自动提交
       set autocommit=1;  //开启自动提交

* 操作事务

       start transaction;  //开启事务(自动提交处于开启状态的时候需要设置,当状态为关闭时不需要设置)
       commit; 提交事务(提交当前会话里的所有未提交操作)
       rollback; 全部回滚事务(回滚当前会话里的所有未提交操作)
       savepoint part1;//设置一个保存点
       rollback to part1; /将savepint = part1的语句到当前语句之间所有的操作回滚

### 十六、数据库部署、主从复制和集群



