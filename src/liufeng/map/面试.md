###ConcurrentHashMap(1.8)

一、讲一讲1.8版本的hash算法
    
    在1.7的基础上&上一个Integer.MAX_VALUE,保证其结果为大于等于零的数,因为hash含义如下：

   |值|含义|
   |:---:|:---:|
   |-1|表示扩容过程中该节点的元素已转移至新数组中|
   |-2|该节点为TreeBin,内部保存红黑树和双向链表|
   |\>=0|该节点为Node,内部保存了单向链表|
    

二、1.8版本的sizeCtl字段的含义
    
    通过无参构造函数生成时,该值为0,表示需要初始化
    通过有参构造函数生成时(指定大小),该值表示初始化时数组的长度
    除上述情况外：
    当sizeCtl>0时,表示扩容阈值
    当sizeCtl<0时,表示正在扩容,同时通过高16位可以计算出数组的大小,低十六位可以计算出此刻参与扩容的线程数(N-1)
    

三、讲一讲1.8版本计数时如何实现的
    
    通过一个baseCount和一个counterCells[]数组实现,
    由于只定义一个baseCount,当并发量高时会有大量的线程计数失败,1.8引入了一个counterCells数组来缓解高并发下大量CAS失败问题
    计数值为baseCount+counterCells数组中暂存的值,类似LongAdder

四、讲一讲1.8版本链表什么时候转化为树
    
    当数组长度大于64且链表长度大于8才会触发链表转树

五、1.8版本扩容过程中可以进行put操作吗
    
    可以,如果该K所在的槽位还未完成元素转移是可能成功的,如果该K所在的槽位已完成转移,put操作的线程必须等扩容完全完成才可以存值

六、扩容时所有的线程都需要帮忙扩容吗
    
    不是,只有那些发现自己需要操作的槽位被标记为已转移的线程才需要帮忙扩容。其他的线程可以继续进行put操作

七、多线程扩容是如何分配任务
    
    通过transferIndex变量进行控制,该变量为volatile类型,按照从右到左的顺序领取任务
    该变量初始值为数组的长度,通过CAS操作保证线程可以领取自己的任务段,当任务完成后,如果transferIndex>0,继续领取新的任务,否则退出

八、读取数据时需要加锁吗
    
    当K所在节点为TreeBin时需要加锁,因为平衡红黑树时root节点不一定代表真正的root,读取时发现如果红黑树在平衡,只能通过TreeBin中的双向链表进行读取
    使用链表读取过程中发现红黑树平衡完成,改为红黑树查找
    其他节点不需要加锁是因为转移的时候不改变原有结构,而是通过生成新的节点进行转移的

九、1.8版本中使用了哪种锁
    
    synchronized锁和读写锁
    synchronized锁用于锁住tab[i],1.6版本对该锁进行了底层优化(先自旋获取锁,自旋指定次数获取不到锁才会阻塞)
    读写锁用于控制红黑树读写正确(防止红黑树平衡过程中使用root查找数据),通过一个volatile变量来控制,读线程发现存在写锁,使用链表读数据,写线程发现读锁,等待读线程结束再写
    
十、HashMap不安全体现在哪里 
    
    1.初始化数组时,可能存在两个线程同时调用,会有一个值丢失
    2.table[i]赋值时,可能存在两个线程同时调用,会有一个值丢失
    3.计数使用i++,可能造成计数值丢失
    4.查询数据时不准确,root节点在平衡时可能造成数据存在但查不出来
十一、扩容时数据如何转移的
    
    hashMap和ConcurrentHashMap树节点转移时是一样的,链表存在差异,主要采用了两个链表来进行转移
    数组扩容后,tab[i]的数据要么位于i处,要么位于i+n处,定义两组head和tail来遍历元素的位置,
    
十二、HashMap如何实现一个LRU算法
    
    LinkedHashMap可以通过HashMap预留的钩子算法实现顺序访问和最近访问排序
    因为在hashMap的基础上多了双向链表来维护顺序